---
title: "리액트 렌더링"
date: 2025-09-24
---
웹 개발을 하다보면 렌더링이라는 단어를 자주 접하게 되는데, 브라우저에서의 렌더링과 리액트에서의 렌더링은 조금 다른 의미를 가지기 때문에 혼동하지 않고 이해하는 것이 중요하다.
이번 포스트에서는 리액트에서의 렌더링 과정에 대해 알아보겠다.
<br><br>

## 리액트에서의 렌더링
리액트에서 **렌더링**이란, 컴포넌트 트리를 순회하며 각 컴포넌트가 갖고 있는 `props`와 `state`를 기반으로 UI를 계산하고, 이를 통해 브라우저 DOM에 어떤 결과를 제공할지 판단하는 프로세스를 의미한다.

- **`props`와 `state`가 없다면?**  
  단순히 JSX가 반환하는 값에 따라 렌더링이 일어난다.

- **`props`나 `state`가 변경된다면?**  
  변경된 값을 기준으로 컴포넌트를 다시 실행하고, 그 결과를 기존 UI와 비교해 필요한 부분을 업데이트한다. 
<br>

## 렌더링은 언제 일어나는가
1. **최초 렌더링**  
   처음 앱에 진입했을 때 발생하며, 앱의 루트 컴포넌트부터 모든 UI를 계산하여 브라우저에 그려낸다.
2. **리렌더링**  
   최초 렌더링 이후 발생하는 모든 렌더링을 의미하며, 주로 props, state, context 변경 등이 트리거가 된다.  
<br>

## 리액트 렌더링의 과정  

1. **업데이트 탐색**  
   리액트는 루트에서부터 내려가면서 업데이트가 필요한 컴포넌트를 찾는다. 

2. **컴포넌트 실행**  
   - 클래스 컴포넌트 -> `render()` 함수 실행
   - 함수 컴포넌트 -> 함수 자체를 호출하고 결과물을 저장 

3. **JSX 변환**  
   JSX는 자바스크립트로 컴파일되며 내부적으로 `React.createElement()` 호출로 변환되는데, 이 함수는 브라우저 UI 구조를 설명하는 일반적인 자바스크립트 객체를 반환한다.

4. **가상 DOM 비교**  
   새로운 가상 DOM과 기존 가상 DOM을 비교해 실제 DOM에 반영할 변경 사항을 수집한다.

5. **DOM 업데이트**  
   변경 사항을 한 번에 적용하여 최종적으로 브라우저 화면이 업데이트된다.
<br>

## 렌더 단계와 커밋 단계  

리액트의 렌더링은 크게 두 단계로 나뉜다.

- **렌더 단계**  
  - 컴포넌트를 실행하고 변경 사항을 계산하는 모든 작업 -> 새로운 결과를 생성  
  - 이전 가상 DOM과 비교하여 변경이 필요한 컴포넌트 탐색
  - 비교 기준: `type`, `props`, `key`  

- **커밋 단계**  
  - 렌더 단계에서 수집된 변경 사항을 실제 DOM에 반영  
  - 이 단계가 끝나야만 브라우저에 변화가 보임  
<br>

## 렌더링 시나리오 예시
```jsx
import { useState } from 'react'

export default function A() {
  return (
    <div className="App">
      <h1>Hello React!</h1>
      <B />
    </div>
  )
}

function B() {
  const [counter, setCounter] = useState(0)

  function handleButtonClick() {
    setCounter((prev) => prev + 1)
  }

  return (
    <>
      <label>
        <C number={counter} />
      </label>
      <button onClick={handleButtonClick}>+</button>
    </>
  )
}

function C({ number }) {
  return (
    <div>
      {number} <D />
    </div>
  )
}

function D() {
  return <>리액트 재밌다!</>
}
```

B 컴포넌트의 버튼 클릭 시 리렌더링 순서: 

1. B 컴포넌트의 `setState` 호출 -> B의 리렌더링 예약  
2. 리액트는 루트인 A부터 렌더링 경로 검사
3. A는 업데이트 없음 -> 패스  
4. B는 업데이트 필요 -> 리렌더링  
5. B는 C를 반환
6. C는 `props`인 `number` 변경됨 -> 리렌더링  
7. C는 D를 반환
8. D는 변경 사항 없음 -> 하지만 부모인 C가 리렌더링됐기 때문에 함께 리렌더링됨
<br>

## 불필요한 렌더링 줄이기  
- 컴포넌트 트리를 효율적으로 구성하면 리렌더링 비용을 줄일 수 있다.
- `memo`로 래핑하면 `props`가 변경되지 않은 경우 렌더링을 생략할 수 있다.
<br>

## 정리  
1. 브라우저에서의 렌더링은 HTML과 CSS 리소스를 기반으로 필요한 UI를 그리는 과정인데, **리액트에서의 렌더링은 UI를 계산하고 DOM에 반영하는 과정**이다.
2. **렌더링은 최초 렌더링과 리렌더링**으로 나뉘며, `props`와 `state` 변경이 주된 트리거이다.
3. 리액트 렌더링은 계산의 **렌더 단계**와 적용의 **커밋 단계**로 진행된다.
4. 컴포넌트 트리 구조와 렌더링 과정을 이해하면 불필요한 렌더링을 줄이고 성능이 좋은 앱을 만들 수 있다.
<br><br>

(출처: 모던 리액트 Deep Dive, 김용찬 저, 위키북스, 2024, p.172-182)
