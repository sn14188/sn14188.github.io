---
title: "CSRF"
date: 2025-11-20
---

웹을 사용하는 동안 우리는 로그인 상태로 수많은 웹사이트를 사용합니다.<br>
자연스러운 행동이지만 여기에 의외로 큰 보안 위험이 숨어있는데, 그중 대표적인 것이 바로 CSRF입니다.
이번 포스트에서는 CSRF 공격이 무엇인지, 이에 대한 방어 기법에 어떤 것들이 있는지 알아보겠습니다.
<br><br>

## CSRF

CSRF는 Cross-Site Request Forgery의 약자로, 인증된 사용자의 브라우저를 이용해 사용자가 의도하지 않은 웹 요청을 웹 앱에 제출하게 만드는 공격입니다.<br>
공격자는 이미지 태그, 숨겨진 폼, 자바스크립트의 `fetch` 또는 `XMLHttpRequest` 등 다양한 방법을 사용할 수 있으며, 이를 통해 사용자의 브라우저가 자동으로 요청을 보내게 만듭니다.<br>

- `<img src>`: 서버로 단순 `GET` 요청이 자동 전송됩니다
- `<form>`: 화면에 표시되지 않아도 다양한 HTTP 요청을 할 수 있습니다
- `fetch`/`XHR`: 자바스크립트 요청으로 `credentials: "include"` 옵션을 사용하면 브라우저가 쿠키를 첨부합니다

이 공격은 XSS가 사용자가 사이트를 신뢰하는 것을 악용하는 것과 달리, CSRF는 사이트가 사용자의 브라우저를 신뢰하는 것을 이용한다는 점이 특징입니다.

### 특성

- "사용자의 인증된 상태"를 전제로 합니다
- 브라우저가 자동으로 해당 도메인에 대한 쿠키를 포함해 요청을 보내는, 웹 브라우저의 일반적인 특성이 이용됩니다
- 공격자는 재현 가능한 요청을 찾아내고, 이를 피해자의 브라우저가 실행하도록 유도합니다
- 공격이 성공하면 계정 조작, 데이터 유출 등이 발생할 수 있습니다

### 동작 방식

브라우저가 각 HTTP 요청을 처리하는 방식이 서로 다르기 때문에 HTTP 메소드에 따라 공격 가능성과 방어 기법이 달라집니다.<br>

1. `GET`: 단순한 링크나 태그만으로도 자동으로 실행될 수 있어 CSRF에 가장 취약합니다
2. `POST`: 사용하는 방식에 따라 공격이 달라집니다
   - 쿼리 스트링 또는 단순 `form` 데이터: `<form>` 태그만으로 공격이 가능합니다
   - `JSON`, `XML` 같은 다른 형식: `fetch`/`XHR`을 사용해 비교적 안전하지만, 서버가 제대로 검사하지 않으면 공격이 가능할 수 있습니다
3. `PUT`, `DELETE` 등:
   - 브라우저는 이 요청들을 HTML 태그로 바로 보낼 수 없고 반드시 `fetch`/`XHR`을 사용해야 합니다
   - 이는 SOP로 보호되지만 서버가 CORS 설정을 잘못해 보호가 없다면 공격이 가능해질 수 있습니다
     - SOP: Same-Origin Policy, 다른 사이트끼리는 서로의 리소스에 접근할 수 없다는 규칙입니다

CSRF 시연은 이 [데모 포스트](https://sn14188.github.io/csrf-demo/)에서 확인할 수 있습니다.

## 방어 기법

대부분의 CSRF 예방 기술은 요청에 추가 인증 데이터를 내장하여 웹 앱이 승인되지 않은 위치에서 오는 요청을 감지할 수 있도록 하는 방식으로 작동합니다.

### 동기화 토큰 패턴 (Synchronizer Token Pattern)

서버는 각 요청마다 고유한 토큰을 HTML 폼 안에 포함시키고, 요청 시 토큰이 유효한지 검사합니다. 가장 전통적이면서도 강력한 CSRF 방어 기법으로, 흔히 CSRF 토큰 방식이라고 부릅니다.<br>
브라우저는 이 토큰을 임의로 만들 수 없기 때문에 공격자가 같은 토큰을 요청에 포함시키는 것이 불가능해집니다.

- 모든 요청마다 토큰을 확인하므로 서버 측의 복잡성이 증가합니다
- 사용자가 여러 탭을 열어두는 경우 토큰이 화면별로 달라 사용성 문제를 일으킬 수 있습니다
  - 회원 정보 수정 탭을 2번 열었을 때 먼저 발급된 토큰을 유효하지 않다고 판단할 수 있습니다
- 이는 세션마다 하나의 CSRF 토큰을 사용하는 방식으로 완화할 수 있습니다

### 쿠키-헤더 토큰 (Cookie-to-Header Token)

초기 방문 시 서버는 랜덤한 CSRF 토큰을 쿠키로 발급하고, 클라이언트 측 자바스크립트는 이 쿠키를 읽어 요청 헤더에 (`X-CSRF-Token`) 실어 전송합니다.<br>
서버는 쿠키에 저장된 토큰 값과 헤더에 담긴 토큰 값이 일치하는지 확인해 요청을 검증합니다.

- 자바스크립트가 쿠키 값을 읽을 수 있어야 하므로 XSS를 막는 수단인 `httpOnly` 플래그를 사용할 수 없습니다

### 더블 제출 쿠키 (Double Submit Cookie)

쿠키-헤더 토큰 방식과 유사한데, 자바스크립트를 사용하지 않는다는 점이 다릅니다. (STP처럼 토큰을 서버에 저장할 필요가 없어 단순합니다)<br>
서버는 CSRF 토큰을 쿠키로 설정하고, 동시에 각 HTML 폼 안의 숨겨진 필드에도 같은 토큰 값을 포함시킵니다. 폼이 제출되면 서버는 쿠키의 토큰과 폼에 담긴 토큰이 일치하는지 확인합니다.

- 사이트가 쿠키를 임의로 설정할 수 있는 기능을 제공한다면, 공격자가 쿠키를 위조해 방어를 우회할 가능성이 있습니다

### 3가지 기법 비교

| 기법                 | 비유                                                      | 비교                                    | JS  |
| -------------------- | --------------------------------------------------------- | --------------------------------------- | --- |
| STP                  | 택배 안에 보안 스티커 1개                                 | 서버에 저장된 스티커 == 택배 안 스티커  | X   |
| Cookie-to-Header     | 택배 안에 보안 스티커 1개, 수령인이 읽고 겉에 번호를 적음 | 택배 안 스티커 == 겉에 적힌 정보 (헤더) | O   |
| Double Submit Cookie | 택배 안에 보안 스티커 2개                                 | 스티커 1 == 스티커 2                    | X   |

### SameSite 쿠키 속성

서버에서 쿠키를 설정할 때 `SameSite` 속성을 추가해, 브라우저가 cross-site 요청에 쿠키를 포함할지 여부를 정할 수 있습니다. 이 방식은 브라우저가 `SameSite` 속성을 올바르게 구현하고 있을 것을 전제로 합니다.

- `SameSite=Strict`:
  - 가장 강력한 모드로 동일 사이트에서 발생한 요청에만 쿠키를 전송합니다
  - 보안은 높지만 UX 이슈로 일반 서비스에서는 잘 사용되지 않습니다
- `SameSite=Lax`:
  - 보안과 사용성의 균형이 좋아 현대 브라우저의 기본값으로 사용됩니다
  - 대부분의 cross-site 요청에는 쿠키를 전송하지 않지만, top-level navigation `GET` 요청에는 쿠키가 포함됩니다
  - top-level navigation:
    - 사용자가 직접 페이지를 이동시키는, 브라우저 주소창이 바뀌는 요청입니다 -> URL 입력, 북마크 클릭, `<a>` 태그를 통한 이동 등
    - `<img src>,` `<script src>`, `fetch()` 등은 top-level navigation이 아닙니다
- `SameSite=None`:
  - 쿠키를 항상 전송합니다
  - 반드시 `secure=true`와 함께 설정해야 합니다

### 클라이언트 측 보안 조치

브라우저 확장 프로그램을 이용해 CSRF를 완화하는 방법들입니다. 기능에 제한이 있거나 일반 사용성에 영향을 준다는 단점이 있습니다.<br>

| Extension                  | 방식                                                                                   | 장점                                  | 단점                           |
| -------------------------- | -------------------------------------------------------------------------------------- | ------------------------------------- | ------------------------------ |
| `RequestPolicy`, `uMatrix` | cross-site 요청을 기본적으로 차단                                                      | 강력함                                | 정상적인 동작을 방해할 수 있음 |
| `CsFire`                   | cross-site 요청에 인증 정보 제거                                                       | 일반적인 웹 탐색에 미치는 영향 최소화 | -                              |
| `NoScript`                 | 신뢰된 사이트와 그렇지 않은 사이트를 구분 -> `POST` 요청에서 인증 정보와 페이로드 제거 | 로컬로 전송되는 요청도 차단 가능      | -                              |
| Self-Destructing Cookies   | 연결되지 않은 쿠키를 즉시 삭제                                                         | 공격 시간을 줄일 수 있음              | 직접적인 CSRF 보호는 아님      |

### 다른 기술들

**`X-Requested-With`/`Referer`/`Origin` 검사:**<br>
요청의 출처를 확인하는 방식은 간단하고 별도 저장소가 필요 없다는 장점이 있지만 아래 단점들이 있습니다.

- 공격자가 `Referer` 헤더를 제거할 수 있습니다 -> `Referer` 헤더가 없는 요청은 허가되지 않은 것으로 처리해야 합니다
- 일부 브라우저 및 프록시가 개인 정보 보호를 위해 `Referer`를 보내지 않습니다

**`GET` 대신 `POST` 사용:**<br>
한때 `GET`으로 공격이 쉽고 `POST`는 안전하다는 오해가 있었으나, 오늘날에는 공격에 모든 HTTP 메소드를 전송할 수 있습니다. 하지만 이 방식은 단순 태그를 악용하는 `GET` 기반 공격 등 특정 유형의 공격에는 효과가 있습니다.

## XSS가 있으면 CSRF 방어의 의미가 없어집니다

CSRF 방어 기법은 모두 정상적인 사용자 요청인지를 검증하는데 XSS가 발생하면 이 모든 보호 장치가 무력화됩니다. 왜냐하면 XSS는 공격자가 정상 사용자의 브라우저 안에서 직접 자바스크립트를 실행할 수 있기 때문입니다.<br>
공격자가 페이지에 삽입한 자바스크립트로 CSRF 토큰을 읽고, 이 세션 쿠키가 포함된 정상적인 요청을 직접 만들어 서버로 보낸다면 서버는 이 요청이 공격인지 실제 요청인지 구분할 방법이 없습니다!

## Takeaways

1. CSRF의 근본적인 원인은 브라우저가 쿠키를 자동으로 포함한다는 것입니다
2. CSRF 방어의 핵심은 추가 검증 정보를 사용한다는 것이다: STP, 더블 제출 쿠키, 쿠키-헤더 토큰 방식 모두 브라우저가 자동으로 붙일 수 없는 값을 사용해 공격을 차단합니다
3. XSS가 발생하면 공격자가 토큰을 읽고 정상 요청처럼 위조할 수 있기 때문에, CSRF를 막기 위해서는 반드시 XSS부터 차단해야 합니다
   <br><br>

_출처:<br>
[1] Wikipedia (["Cross-site request forgery"](https://en.wikipedia.org/wiki/Cross-site_request_forgery))<br>_
