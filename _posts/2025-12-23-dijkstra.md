---
title: "Dijkstra's Algorithm"
date: 2025-12-23
---

다익스트라 알고리즘을 공부하고 정리해본 기록입니다.
<br><br>

## Dijkstra's Algorithm

다익스트라 알고리즘은 교통망 같은 곳에서 나타날 수 있는 그래프에서 정점 간의 최단 경로를 찾는 알고리즘입니다.<br>
원래 알고리즘은 두 정점 간의 가장 짧은 경로를 찾는 알고리즘이지만, 더 일반적인 변형은 한 정점을 시작으로 고정하고 다른 모든 정점들까지의 최단 경로를 찾는 알고리즘으로 최단 경로 트리를 만드는 것입니다.

- 그래프: 정점과 정점들을 연결하는 간선으로 이루어진 자료 구조

다익스트라의 원래 알고리즘은 priority queue를 사용하지 않았기 때문에 시간 복잡도가 $$O(V^2)$$이며,
최소 priority queue에 기반한 알고리즘은 피보나치 힙으로 수행되며 시간 복잡도는 $$O(E+VlogV)$$입니다.

## Algorithm

다익스트라 알고리즘도 벨만-포드와 마찬가지로 relaxation을 사용합니다.<br>
relaxation이란 그래프를 순회하며 경로를 찾는 과정에서 더 비용이 작은 경로가 발견되면 그 정보를 갱신하는 과정을 말합니다.

1. 모든 정점을 미방문 상태로 표시합니다
2. 모든 정점에 비용을 부여합니다: 시작 정점은 0으로, 다른 모든 정점들은 무한대로 놓습니다
3. 현재 정점에서 미방문 인접 정점들을 찾아 비용을 계산합니다: 여기서 relaxation을 사용합니다
4. 3의 비용 계산 과정이 끝나면 "방문했다고" 처리합니다
5. 두 정점 사이의 경로를 찾는 경우, 도착이 방문한 상태로 표시되면 멈추고 알고리즘을 종료합니다
6. 아니면 비용이 제일 작은 정점을 새로운 "현재"로 선택하고 3으로 되돌아갑니다

다음 정점 `A`를 시작으로 정점 `E`까지 가는 최단 경로를 다익스트라 알고리즘으로 찾아보겠습니다.<br>
모든 정점을 미방문 상태로 표시하고, 비용을 부여했습니다.<br><br>
<img src='/images/dijkstra/dijkstra_0.png' width="800">

첫째 반복에서 `A`와 연결된 `B`, `C`, `F`의 비용이 계산되고, `A`는 최소 비용을 0으로 확정하며 방문 처리됩니다.<br>
그중 최소인 `B`가 새로운 "현재"가 됩니다.<br><br>
<img src='/images/dijkstra/dijkstra_1.png' width="800">

둘째 반복에서 `B`는 `A`, `C`, `D`와 연결돼있지만 이미 방문 처리된 `A`는 고려되지 않습니다.<br>
relaxation으로 `C`의 비용을 갱신하고 `D`도 계산한 뒤, `B`는 최소 비용을 7로 확정하며 방문 처리됩니다.<br>
이제 `C`, `D` 중 최소인 `C`가 새로운 "현재"가 됩니다.
<br><br>
<img src='/images/dijkstra/dijkstra_2.png' width="800">

셋째 반복에서 `C`는 `D`와 `F`를 모두 갱신한 뒤 방문 처리됩니다. 둘 중 최소인 `F`가 새로운 "현재"가 됩니다.<br><br>
<img src='/images/dijkstra/dijkstra_3.png' width="800">

넷째 반복에서 `F`는 `E`의 비용을 계산하고, 목적지에 도달했으므로 최소 비용 20으로 알고리즘을 종료할 수 있습니다.<br>
이 경우 최단 경로는 `A` -> `C` -> `F` -> `E`가 됩니다.<br><br>
<img src='/images/dijkstra/dijkstra_4.png' width="800">

## Implementation

이 알고리즘으로 [프로그래머스의 배달 문제](https://school.programmers.co.kr/learn/courses/30/lessons/12978)를 풀어보겠습니다.<br>
`N`개의 마을로 이루어진 나라에서, 각 마을들이 양방향 도로로 연결돼있고, 1번 마을에 있는 음식점에서 다른 마을들로 제한된 시간 `K` 이내에 음식 배달을 하는 문제입니다.<br>
먼저 제 루틴대로 스크립트에 테스트 케이스들을 추가했고, 함수 시그니처를 정의했습니다.

```py
def solution(N: int, road: list[list[int]], K: int) -> int:
    """
    idea:
    - 그래프 구성
    - 거리 리스트와 방문 여부 초기화
    - 반복: 미방문 정점들 중 최단 거리 정점 선택, 인접 정점들에 relaxation, 해당 정점 방문 처리
    - K 이하 시간의 정점 계수
    """

    answer = 0
    return answer
```

출발 정점을 키로 하고, 도착 정점과 소요 시간을 튜플로 묶은 값을 가지는 `graph`라는 이름의 딕셔너리를 생성했습니다.<br>
하나의 마을이 여러 마을과 연결될 수 있으므로, 값은 리스트로 구성했습니다.<br>
양방향임을 간과한 채 코드를 작성하다가, 도착 정점에서 출발 정점으로 이동하려는 경우에 `KeyError`가 발생하면서 이를 인지하게 됐습니다!
출발 정점과 도착 정점을 바꾼 경우에도 이동이 가능하므로, 서로 바꾼 정보도 `graph`에 추가했습니다.

```py
def solution(N: int, road: list[list[int]], K: int) -> int:
    graph = dict()
    for dep, arr, time in road:
        if dep not in graph:
            graph[dep] = [(arr, time)]
        else:
            graph[dep].append((arr, time))

        if arr not in graph:
            graph[arr] = [(dep, time)]
        else:
            graph[arr].append((dep, time))

    answer = 0
    return answer
```

각 정점까지의 최단 소요 시간을 저장하기 위한 리스트를 생성하고,
해당 정점의 인접 정점들에 대한 거리 갱신이 모두 끝났는지를 표시하기 위해 `visited` 이름의 `boolean` 리스트를 함께 도입했습니다.<br>
마을 번호가 1부터 시작하고 0번 마을은 존재하지 않기 때문에, 인덱스를 맞추기 위한 편의상 리스트의 길이를 하나 더 늘려 사용했습니다.

```py
def solution(N: int, road: list[list[int]], K: int) -> int:
    graph = dict()
    for dep, arr, time in road:
        if dep not in graph:
            graph[dep] = [(arr, time)]
        else:
            graph[dep].append((arr, time))

        if arr not in graph:
            graph[arr] = [(dep, time)]
        else:
            graph[arr].append((dep, time))

    visited = [False] * (N + 1)
    dist = [float("inf")] * (N + 1)
    dist[1] = 0

    answer = 0
    return answer
```

반복되는 로직에서는 미방문 정점들 중 최단 거리를 가진 정점을 선택하고, 해당 정점의 인접 정점들에 대해 relaxation을 수행한 뒤, 그 정점을 방문 처리합니다.<br>
모든 정점을 방문했거나, 아직 방문하지 않은 정점들의 거리가 모두 무한대인 경우에는 도달할 수 없다고 생각해 반복을 종료했습니다.<br>
한 번의 반복에서 `visited`로 최단 비용이 확정되는 정점은 하나뿐이므로, 이 과정은 최대 `N`번 반복하면 충분합니다.

```py
def solution(N: int, road: list[list[int]], K: int) -> int:
    ...

    for _ in range(N):
        curr = -1
        min_dist = float("inf")

        for i in range(1, N + 1):
            if not visited[i] and dist[i] < min_dist:
                curr = i
                min_dist = dist[i]

        if curr == -1:
            break

        if curr in graph:
            for arr, time in graph[curr]:
                if dist[arr] > dist[curr] + time:
                    dist[arr] = dist[curr] + time

        visited[curr] = True

    answer = 0
    return answer
```

마지막으로 `K` 이하의 정점들을 계수해줬습니다.

```py
def solution(N: int, road: list[list[int]], K: int) -> int:
    ...

    for _ in range(N):
        curr = -1
        min_dist = float("inf")

        for i in range(1, N + 1):
            if not visited[i] and dist[i] < min_dist:
                curr = i
                min_dist = dist[i]

        if curr == -1:
            break

        if curr in graph:
            for arr, time in graph[curr]:
                if dist[arr] > dist[curr] + time:
                    dist[arr] = dist[curr] + time

        visited[curr] = True

    answer = 0
    for d in dist:
        if d <= K:
            answer += 1

    return answer
```

현재 구현은 미방문 정점 중 최단 거리 정점을 선형 탐색으로 선택하는 정통 다익스트라 알고리즘입니다.
그런데 이 "선형 탐색" 때문에 시간 복잡도는 $$O(V^2)$$이 됩니다.<br>
해당 선택 과정을 최소 priority queue를 이용해 구현하면, 알고리즘의 논리 구조는 그대로 유지하면서 전체 시간 복잡도를 $$O(E+VlogV)$$로 개선할 수 있습니다.<br>
이를 적용한 전체 구현은 다음과 같습니다.

```py
import heapq

def solution(N: int, road: list[list[int]], K: int) -> int:
    graph = dict()
    for dep, arr, time in road:
        if dep not in graph:
            graph[dep] = [(arr, time)]
        else:
            graph[dep].append((arr, time))

        if arr not in graph:
            graph[arr] = [(dep, time)]
        else:
            graph[arr].append((dep, time))

    dist = [float("inf")] * (N + 1)
    dist[1] = 0

    pq = []
    heapq.heappush(pq, (0, 1))

    while pq:
        curr_dist, curr = heapq.heappop(pq)

        if curr_dist > dist[curr]:
            continue

        if curr in graph:
            for arr, time in graph[curr]:
                new_dist = curr_dist + time
                if dist[arr] > new_dist:
                    dist[arr] = new_dist
                    heapq.heappush(pq, (new_dist, arr))

    answer = 0
    for d in dist:
        if d <= K:
            answer += 1

    return answer
```

<br><br>

_출처:<br>
[1] Wikipedia (["Dijkstra's algorithm"](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm))<br>_
