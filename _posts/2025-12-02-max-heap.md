---
title: "Max Heap in Python"
date: 2025-12-02
---

파이썬으로 Max Heap을 직접 구현해본 기록입니다.
<br><br>

## Motivation

이번에 Max Heap을 구현해보기로 한 이유는 두 가지입니다.

1. 예전에 풀었던 [관련 문제](https://github.com/sn14188/coding-test-lab/blob/main/2025/1127-double-priority-queue.py)에서는 [라이브러리](https://docs.python.org/3/library/heapq.html)만 사용해 해결했기 때문에, 이번에는 직접 구현까지 해보고 싶었습니다
2. `heapq`가 Min Heap만 지원해 Max Heap이 필요하면 번거로운 우회가 필요하므로, 직접 Max Heap을 만들어보고자 했습니다

## Overview

Max Heap은 리스트 기반의 완전 이진 트리 구조이므로 기본적으로 `push`, `pop` 연산이 필요합니다.<br>
그리고 이 연산들이 수행될 때, 힙의 성질을 유지하는 `heapify` 과정이 반드시 필요합니다.<br>
Max Heap의 조건은 다음과 같습니다:

1. 부모 노드는 항상 자식 노드들보다 크다
2. 루트가 전체에서 가장 큰 값이다

`heapify`는 요소가 삽입되거나 삭제될 때 트리를 따라 이동하며 힙 구조를 복원하는 역할을 합니다.

## Implementation

### 클래스 초기화

힙은 배열 하나로 표현할 수 있으므로, 컨스트럭터에서는 리스트만 초기화해줍니다.

```py
class MaxHeap:
    def __init__(self):
        self.elems = []
```

### push

새 요소는 항상 리스트의 마지막에 추가합니다. 추가된 요소가 힙의 성질을 만족하도록 부모와 비교하여 위로 끌어올립니다.

```py
def push(self, elem):
    self.elems.append(elem)
    self._heapify_up(len(self.elems) - 1)
```

여기서 `_heapify_up`은 클래스 내부에서만 사용되므로 언더스코어를 붙여 추상화했습니다.

### \_heapify_up

파라미터로 새로 추가된 요소의 인덱스를 사용합니다. 부모의 인덱스는 `(i - 1) // 2`로 계산할 수 있고, 만약 자식이 부모보다 크다면 두 값을 교환합니다.<br>
부모와 교환되었다는 건, 새 부모 값이 기존의 자식보다 크다는 의미이므로 그 서브트리에서 힙의 성질은 그대로 유지됩니다.<br>
이 과정을 루트까지 반복하면 전체 구조를 Max Heap 형태로 만들 수 있습니다.

```py
def _heapify_up(self, idx):
    elems = self.elems

    while idx > 0:
        parent = (idx - 1) // 2

        if elems[idx] <= elems[parent]:
            break

        elems[idx], elems[parent] = elems[parent], elems[idx]
        idx = parent
```

### pop

힙에서 `pop`은 루트를 반환하는 과정입니다.<br>
하지만 루트 값을 제거한다고 해서 리스트 전체를 당겨오지는 않고, 처리는 다음과 같은 순서로 합니다:

1. 루트 값을 임시로 저장
2. 마지막 요소를 꺼내 루트에 넣음
3. 루트에서 시작해 `_heapify_down`으로 자신의 위치를 찾아가도록 함

```py
def pop(self):
    if not self.elems:
        return None

    max_val = self.elems[0]
    last_val = self.elems.pop()

    if self.elems:
        self.elems[0] = last_val
        self._heapify_down(0)

    return max_val
```

### \_heapify_down

루트가 바뀌었기 때문에, 자식 노드들과 값을 비교하며 더 큰 쪽과 교환해 내려가는 방식으로 힙을 정리합니다.

```py
def _heapify_down(self, idx):
    elems = self.elems
    size = len(elems)

    while True:
        largest = idx
        left = idx * 2 + 1
        right = idx * 2 + 2

        if left < size and elems[largest] < elems[left]:
            largest = left

        if right < size and elems[largest] < elems[right]:
            largest = right

        if largest == idx:
            break

        elems[idx], elems[largest] = elems[largest], elems[idx]
        idx = largest
```

## 전체 코드

```py
class MaxHeap:
    def __init__(self):
        self.elems = []

    def push(self, elem):
        self.elems.append(elem)
        self._heapify_up(len(self.elems) - 1)

    def pop(self):
        if not self.elems:
            return None

        max_val = self.elems[0]
        last_val = self.elems.pop()

        if self.elems:
            self.elems[0] = last_val
            self._heapify_down(0)

        return max_val

    def _heapify_up(self, idx):
        elems = self.elems

        while idx > 0:
            parent = (idx - 1) // 2

            if elems[idx] <= elems[parent]:
                break

            elems[idx], elems[parent] = elems[parent], elems[idx]
            idx = parent

    def _heapify_down(self, idx):
        elems = self.elems
        size = len(elems)

        while True:
            largest = idx
            left = idx * 2 + 1
            right = idx * 2 + 2

            if left < size and elems[largest] < elems[left]:
                largest = left

            if right < size and elems[largest] < elems[right]:
                largest = right

            if largest == idx:
                break

            elems[idx], elems[largest] = elems[largest], elems[idx]
            idx = largest
```
