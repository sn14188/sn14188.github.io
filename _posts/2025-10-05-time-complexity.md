---
title: "Time Complexity"
date: 2025-10-05
---

알고리즘의 효율을 정량화할 수 있는 도구에 시간 복잡도와 공간 복잡도가 있는데, 이번 포스트에서는 시간 복잡도에 대해 정리해봤습니다.
<br><br>

## 시간 복잡도

시간 복잡도는 입력 크기 $$n$$이 커질 때 필요한 연산 횟수가 어떻게 증가하는지를 나타냅니다.<br>
예를 들어 $$N$$개의 데이터에서 어떤 값을 앞에서부터 차례대로 검사한다면, 최악의 경우 $$N$$번 비교가 필요합니다. 데이터가 1개면 금방 끝나지만, 100개, 10,000개로 커질수록 평균적으로 더 오래 걸리게 됩니다.<br>
실제 코드의 실행 시간은 코드를 돌리는 기계나 언어 같은 다른 요인의 영향을 받지만, 연산 횟수의 증가율로 일관된 비교 기준을 마련할 수 있습니다.

## 점근 표기법

데이터의 개수가 10,000개여도 알고리즘 실행이 일찍 종료될 때가 있고, 실제로 10,000번의 연산이 다 수행돼야 하는 때가 있습니다.
이런 들쭉날쭉한 데이터를 일반적으로 설명하기 위해 등장한 것이 점근 표기법이며, 어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 방법입니다.

### 종류

- **Big _O_**: 입력하는 $$n$$에 대해 실행 시간이 대략 이 이상은 커지지 않을 것이라는 의미입니다. 예를 들어 $$O(n^2)$$은 입력 $$n$$이 증가하더라도 실행 시간의 증가율이 $$n^2$$보다는 작거나 같다는 것을 표현합니다.
- **Big _Θ_**: 입력에 대한 평균적인 실행 시간을 의미합니다. 예를 들어 $$\Theta(n^2)$$은 입력 $$n$$이 증가하더라도 실행 시간의 증가율이 $$n^2$$와 같은 급임을 표현합니다.
- **Big _Ω_**: 입력에 대한 실행 시간의 점근적 하한을 의미합니다. 예를 들어 $$\Omega(n^2)$$은 입력 $$n$$이 증가하더라도 실행 시간의 증가율이 $$n^2$$보다 크거나 같음을 표현합니다.

이중 Big *O*가 가장 많이 사용됩니다. 왜냐하면 알고리즘은 빠를수록 좋고, 빠른 게 좋다는 관점에서 최악의 경우만 고려하면 되기 때문일 것입니다.
Big _O_ 표기법을 좀 더 깊이 있게 알아보겠습니다.

### 수식 정의

"모든 $$x\geq x_0$$에 대해 $$f(x)\leq cg(x)$$를 만족하는 양의 상수 $$c$$와 $$x_0$$가 존재할 경우, $$O(g(x))=f(x)$$이다."<br>
이렇게 수식으로 정의했을 때 의미가 더 뚜렷해지지만, 변수와 상수 때문에 다소 복잡하게 느껴질 수 있으니 아래의 두 가지 증명 예들을 통해 살펴보겠습니다.

1. 왜 $$f(n)=n^2-3n-5$$는 $$O(n^2)$$인가요?<br>
   <br>
   $$f(n)=n^2-3n-5$$가 $$O(n^2)$$임을 증명하기 위해서는, Big _O_ 정의에 따라 $$n^2-3n-5\leq cn^2$$를 만족하는 양의 상수 $$c_0$$와 $$n_0$$를 찾으면 됩니다.<br>
   좌변 $$n^2-3n-5$$에 임의로 $$(3n+5)$$를 더하면, 특정한 상수 $$n_0$$보다 큰 범위에 대해 $$n^2-3n-5\leq n^2-3n-5+(3n+5)$$가 항상 성립합니다.<br>
   이를 만족하는 최소 $$n_0$$을 찾을 수도 있지만, 증명에 값 존재 여부만 필요하고 보통 입력 $$n$$을 자연수로 보므로 $$n_0$$를 1로 두어도 충분합니다.<br>
   우변을 정리하면 $$n^2-3n-5\leq n^2$$이 되고, 우변 $$n^2=cn^2$$로 양의 상수 $$c_0$$를 1로 잡으면 됩니다.<br>
   정의에 따라, $$n^2-3n-5$$은 $$O(n^2)$$입니다.

2. 왜 $$f(n)=3n^2+6n$$는 $$O(n)$$이 아닌가요?<br>
   <br>
   같은 빌드업으로 증명할 수 있습니다. $$n_0$$보다 큰 모든 $$n$$에 대해 $$3n^2+6n\leq cn$$를 만족하는 양의 상수 $$c_0$$를 찾으면 됩니다.<br>
   $$n_0$$은 자연수이므로, 양변을 $$n$$으로 나누어도 부등호의 방향은 바뀌지 않습니다.<br>
   부등식을 $$c_0$$에 대해 풀면 $$c_0\geq (3n^2+6n)/n$$이 되고, 간단히 하면 $$c_0\geq 3n+6$$이 됩니다.<br>
   그런데 여기서 $$n$$의 값에 따라 상수 $$c_0$$가 변할 수 있다는 점에서 모순이 됩니다. 그래서 $$f(n)=3n^2+6n$$는 $$O(n)$$이 아니라는 결론을 얻을 수 있습니다.<br>

여기서 우리는 점근 표기법에서는 다항식의 경우 상수와 낮은 차수 항을 버리고 최고차항만 보면 되며, 복잡도는 그 차수로 정해진다는 것을 알 수 있습니다.

## 시간 복잡도 비교

<img src='/images/time-complexity/time-complexity-comparison.png' width="800">

- 점근적 관점에서 $$O(1)$$ -> $$O(log n)$$ -> $$O(n)$$ -> $$O(n log n)$$ -> $$O(n^2)$$ -> $$O(2^n)$$ -> $$O(n!)$$ 순으로 비용이 커집니다
- $$O(n!)$$가 가장 비싸고, $$O(2^n)$$도 빠르게 증가합니다
- $$O(2^n)$$보다는 $$O(n^2)$$가 낫습니다
- $$O(1)$$이 가장 좋습니다

### 동일한 기능의 알고리즘이이어도 성능이 다를 수 있습니다

| 정렬 알고리즘 | 시간 복잡도  |
| ------------- | ------------ |
| 삽입 정렬     | $$O(n^2)$$   |
| 선택 정렬     | $$O(n^2)$$   |
| 버블 정렬     | $$O(n^2)$$   |
| 병합 정렬     | $$O(nlogn)$$ |
| 퀵 정렬       | $$O(nlogn)$$ |
| 힙 정렬       | $$O(nlogn)$$ |

### 시간 복잡도와 Big _O_ 표기법의 차이

- 시간 복잡도: 입력의 크기에 따른 프로그램의 실행 시간 관계를 말하며, 연산 횟수에 비례합니다
- Big _O_ 표기법: 함수의 점근적 상한을 말하며, 시간 복잡도를 표현하기 위해 자주 사용됩니다

## Takeaways

1. 시간 복잡도는 입력이 커질 때 연산량이 얼마나 빨리 늘어나는지를 비교하는 기준입니다
2. 동일한 기능이라도 알고리즘 선택에 따라 입력에서 성능에 차이가 커질 수 있습니다
3. 점근 표기법은 증가 속도를 "상한" 기준으로 비교하며, Big *O*가 가장 많이 사용됩니다
   <br><br><br>

_출처:<br>
[1] 이것이 취업을 위한 컴퓨터 과학이다, 강민철 저, 한빛미디어, 2024, p. 257-263, 337-338<br>_
