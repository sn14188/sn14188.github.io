---
title: "시간 복잡도"
date: 2025-10-05
---
알고리즘의 효율에 대한 질문은 늘 따라다닌다. 이 질문의 답을 정량화할 수 있는 도구가 시간 복잡도와 공간 복잡도인데, 이번 포스트에서는 시간 복잡도에 대해 정리해보겠다.
<br><br>

## 시간 복잡도
시간 복잡도는 입력 크기 $$n$$이 커질 때 필요한 연산 횟수가 어떻게 증가하는지를 나타낸다.<br>
예를 들어 $$N$$개의 데이터에서 어떤 값을 앞에서부터 차례대로 검사한다면, 최악의 경우 $$N$$번 비교가 필요하다. 데이터가 1개면 금방 끝나지만, 100개, 10,000개로 커질수록 평균적으로 더 오래 걸린다.<br>
실제 코드의 실행 시간은 기계나 언어 같은 다른 요인의 영향을 받지만, 연산 횟수의 증가율로 일관된 비교 기준을 마련할 수 있다.
<br><br>

## 점근 표기법
그런데 데이터의 개수가 10,000개여도 실행이 일찍 종료될 때가 있고 실제로 10,000번의 연산이 다 수행돼야 하는 때가 있다. 이런 들쭉날쭉한 데이터를 일반적으로 설명하기 위해 등장한 것이 점근 표기법이며,
어떤 함수의 증가 양상을 다른 함수와의 비교로 표현하는 방법이다.
<br>

### 종류
1. **Big *O***  
   입력하는 $$n$$에 대해 실행 시간이 대략 이 이상은 커지지 않을 것이라는 의미이다. 예를 들어 $$O(n^2)$$은 입력 $$n$$이 증가하더라도 실행 시간의 증가율이 $$n^2$$보다는 작거나 같다는 것을 표현한다.

2. **Big *Θ***  
   입력에 대한 평균적인 실행 시간을 의미한다. 예를 들어 $$\Theta(n^2)$$은 입력 $$n$$이 증가하더라도 실행 시간의 증가율이 $$n^2$$와 같은 급임을 표현한다.
   
4. **Big *Ω***  
   입력에 대한 실행 시간의 점근적 하한을 의미한다. 예를 들어 $$\Omega(n^2)$$은 입력 $$n$$이 증가하더라도 실행 시간의 증가율이 $$n^2$$보다 크거나 같음을 표현한다.

이중 **Big *O***가 가장 많이 사용된다. 왜냐하면 알고리즘은 빠를수록 좋고, 빠른 게 좋다는 관점에서 최악의 경우만 고려하면 되기 때문일 것이다. 그래서 **Big *O*** 표기법을 좀 더 깊이 있게 알아보겠다.
<br>

### 수식 정의
모든 $$x\geq x_0$$에 대해 $$f(x)\leq cg(x)$$를 만족하는 양의 상수 $$c$$와 $$x_0$$가 존재할 경우, $$O(g(x))=f(x)$$이다.<br>

위와 같이 수식으로 정의했을 때 의미가 더 뚜렷해질 수 있다. 다만 변수와 상수 때문에 다소 복잡하게 느껴질 수 있으니, 두 가지 증명 예들을 통해 살펴보겠다.

1. 왜 $$f(n)=n^2-3n-5$$는 $$O(n^2)$$인가?
<br><br>
$$f(n)=n^2-3n-5$$가 $$O(n^2)$$임을 증명하기 위해서는, **Big *O*** 정의에 따라 $$n^2-3n-5\leq cn^2$$를 만족하는 양의 상수 $$c_0$$와 $$n_0$$를 찾으면 된다.<br>
좌변 $$n^2-3n-5$$에 임의로 $$(3n+5)$$를 더하면, 특정한 상수 $$n_0$$보다 큰 범위에 대해 $$n^2-3n-5\leq n^2-3n-5+(3n+5)$$가 항상 성립한다.<br>
이를 만족하는 최소 $$n_0$$을 찾을 수도 있지만, 증명에 값 존재 여부만 필요하고 보통 입력 $$n$$을 자연수로 보므로 $$n_0$$를 1로 두어도 충분하다.<br>
우변을 정리하면 $$n^2-3n-5\leq n^2$$이 되고, 우변 $$n^2=cn^2$$로 양의 상수 $$c_0$$를 1로 잡으면 된다.<br>
정의에 따라, $$n^2-3n-5$$은 $$O(n^2)$$이다.
<br>

2. 왜 $$f(n)=3n^2+6n$$는 $$O(n)$$이 아닌가?
<br><br>
같은 빌드업으로 증명할 수 있다. $$n_0$$보다 큰 모든 $$n$$에 대해 $$3n^2+6n\leq cn$$를 만족하는 양의 상수 $$c_0$$를 찾으면 된다.<br>
$$n_0$$은 자연수이므로, 양변을 $$n$$으로 나누어도 부등호의 방향은 바뀌지 않는다.<br>
부등식을 $$c_0$$에 대해 풀면 $$c_0\geq (3n^2+6n)/n$$이 되고, 간단히 하면 $$c_0\geq 3n+6$$이 된다.<br>
그런데 여기서 $$n$$의 값에 따라 상수 $$c_0$$가 변할 수 있다는 점에서 모순이 된다. 그래서 $$f(n)=3n^2+6n$$는 $$O(n)$$이 아니라는 결론을 얻을 수 있다.
<br><br>

여기서 우리는 점근 표기법에서는 다항식의 경우 상수와 낮은 차수 항을 버리고 최고차항만 보면 되며, 복잡도는 그 차수로 정해진다는 것을 알 수 있다.<br>
계단을 한 번에 1칸을 오르든 2칸을 오르든 올라야 하는 칸은 "층"에 비례해 늘어나는 게 주안점이다.
<br>

## 시간 복잡도 비교
<img src='/images/A-comparison-of-algorithm-time-complexity.png'>

- 점근적 관점에서 $$O(1)$$ -> $$O(log n)$$ -> $$O(n)$$ -> $$O(n log n)$$ -> $$O(n^2)$$ -> $$O(2^n)$$ -> $$O(n!)$$ 순으로 비용이 커진다
- $$O(n!)$$가 가장 비싸고, $$O(2^n)$$도 빠르게 증가한다
- $$O(2^n)$$보다는 $$O(n^2)$$가 낫다
- $$O(1)$$이 가장 좋다

### 동일한 기능의 알고리즘이이어도 성능이 다를 수 있다

| 정렬 알고리즘 | 시간 복잡도 |
|-|-|
| 삽입 정렬 | $$O(n^2)$$ |
| 선택 정렬 | $$O(n^2)$$ |
| 버블 정렬 | $$O(n^2)$$ |
| 병합 정렬 | $$O(nlogn)$$ |
| 퀵 정렬 | $$O(nlogn)$$ |
| 힙 정렬 | $$O(nlogn)$$ |

<br>

## 연습문제
### 더 효율적인 코드는

```python
def first(arr):
  n = len(arr)

  for i in range(n):
    for j in range(0, n - i - 1):
      if arr[j] > arr[j + 1]:
        arr[j], arr[j + 1] = arr[j + 1], arr[j]

  return arr
```
```python
def second(arr):
  n = len(arr)

  for i in range(n):
    for j in range(i + 1, n):
      for k in range(j + 1, n):
        if arr[i] > arr[j]:
          arr[i], arr[j] = arr[j], arr[i]
        if arr[j] > arr[k]:
          arr[j], arr[k] = arr[k], arr[j]
        if arr[i] > arr[j]:
          arr[i], arr[j] = arr[j], arr[i]

  return arr
```

### 시간 복잡도와 Big *O* 표기법의 차이
   - 시간 복잡도: 입력의 크기에 따른 프로그램의 실행 시간 관계 -> 연산 횟수에 비례
   - Big *O* 표기법: 함수의 점근적 상한, 시간 복잡도를 표현하기 위해 자주 사용됨
<br>

## 정리
1. 시간 복잡도는 입력이 커질 때 연산량이 얼마나 빨리 늘어나는지를 비교하는 기준이다.
2. 동일한 기능이라도 알고리즘 선택에 따라 입력에서 성능에 차이가 커질 수 있다.
3. 점근 표기법은 증가 속도를 "상한" 기준으로 비교하며, Big *O*가 가장 많이 사용된다.
<br><br><br>

*(출처: [이미지 출처](https://www.researchgate.net/figure/A-comparison-of-algorithm-time-complexity_fig1_311754895), 이것이 취업을 위한 컴퓨터 과학이다, 강민철 저, 한빛미디어, 2024, p. 257-263, 337-338)*
