---
title: "pnpm과 하드/심볼릭 링크"
date: 2025-10-30
---
Node.js 프로젝트에서 대부분 패키지 매니저로 npm이나 yarn을 사용합니다. 이번 부트캠프를 통해 pnpm을 처음 알게 됐고 팀 프로젝트에서 잘 사용하고 있습니다.<br>
pnpm을 사용함으로써 전역 저장소에 패키지를 한 번만 저장해 공간을 절약할 수 있다고 배웠는데, 어떻게/왜 그런 것인지 궁금해 원리를 조금 더 들여다봤습니다.
<br><br>

## 패키지 매니저
어떤 소프트웨어를 어떤 버전으로 어디에 설치하고 유지할지를 대신 결정하고 실행해주는 자동화 도구입니다.<br>
npm과 yarn은 JavaScript/TypeScript 프로젝트에서 외부 라이브러리를 관리하는 도구이며, 기본적으로 다음 역할을 수행합니다.

- 패키지 설치: 패키지를 다운로드해 `node_modules/`에 넣고, `package.json`과 `lock` 파일을 업데이트합니다
  - `npm init`으로 `package.json`를 생성합니다 (이때 아직 `dependencies`는 비어있습니다)
  - `npm install`로 `package.json`의 `dependencies`를 추가하며, `package-lock.json`를 생성해 정확한 버전을 기록합니다
- 의존성 해결: 추가한 패키지는 물론 그 패키지가 의존하는 패키지들을 전부 가져옵니다
- 버전 잠금: `package-lock.json`으로 정확한 버전들을 기록해 의존성 트리를 재현할 수 있게 합니다
- 스크립트 실행: `npm run build` 등 `package.json`에 스크립트를 정의해 실행할 수 있습니다

## pnpm
현대적 패키지 매니저인 Performant Node Package Manager는 Node.js 생태계를 위한 효율적인 패키지 매니저로, 하드 링크와 심볼릭 링크를 활용해 중복 설치를 최소화합니다.<br>
npm이나 yarn은 프로젝트별로 `node_modules/` 복사본을 통째로 넣어 여러 프로젝트가 같은 라이브러리를 쓰면 디스크 낭비가 발생합니다. 실제로 `node_modules/` 폴더가 굉장히 크기 때문에, 특정 패키지를 검색하는 데에 리소스가 많이 쓰이고 아래 프로젝트 예시처럼 둘 이상의 동일한 패키지가 있는 경우 중복해서 저장해야 하기 때문에 리소스가 또 낭비될 수 있습니다.
```ts
meong-road
├── frontend
│   ├── package.json
│   └── node_modules
└── backend
    ├── package.json
    └── node_modules
```
이런 프로젝트들이 많다면 더욱 낭비일 것입니다.<br>
하지만 pnpm은 모든 패키지를 전역 저장소 한 곳에 한 번만 다운로드하며, 각 프로젝트에서는 그 저장소의 파일로 하드 링크를 걸고, 의존성 구조는 심볼릭 링크로 표현합니다.

## 하드 링크와 심볼릭 링크
### 하드 링크
파일의 실제 데이터를 공유하는 또 하나의 이름입니다.

- 원본 파일과 하드 링크는 같은 파일 데이터를 공유합니다
- 그래서 한쪽을 수정하면 다른 쪽도 그대로 바뀝니다
- 원본 파일이 삭제되거나 이동되더라도, 다른 링크가 남아있다면 파일 데이터에 접근할 수 있습니다

### 심볼릭 링크
다른 파일이나 폴더의 경로를 가리키는 포인터입니다.

- 원본 파일의 위치만을 저장합니다
- 원본 파일이 삭제되거나 이동되는 경우에는 사용이 불가능합니다

따라서 하드 링크는 동일한 파일을 여러 이름으로 참조하고 싶을 때, 심볼릭 링크는 복잡한 경로에 있는 파일을 참고하고 싶을 때 사용할 수 있습니다.

## 공식 문서 예시
### 시나리오
pnpm은 의존성의 중첩된 구조를 만드는 데에 심볼릭 링크를 사용합니다.<br>
아래와 같이 `bar@1.0.0`에 의존하는 `foo@1.0.0`을 설치하는 상황을 가정해보겠습니다.
```ts
node_modules
└── .pnpm
    ├── bar@1.0.0
    │   └── node_modules
    │       └── bar
    │           ├── index.js     -> <store>/001
    │           └── package.json -> <store>/002
    └── foo@1.0.0
        └── node_modules
            └── foo
                ├── index.js     -> <store>/003
                └── package.json -> <store>/004
```
이들은 `.pnpm` 폴더 안에 설치되는 실제 파일들이며 이들은 전역 저장소인 `<store>`에 저장됩니다. `foo@1.0.0`를 설치하는 시나리오에서, 이의 의존성으로 `bar@1.0.0`를 필요로 하게 돼 pnpm은 `foo@1.0.0`와 `bar@1.0.0` 둘 다 다운로드합니다.<br>
문서에서 "real" 파일이라 적혀있어 오해가 좀 있는 것 같습니다. 하지만 여기서 말하는 파일들은 `<store>`에 있는 파일에 대한 "하드 링크"이며, 파일 시스템 수준에서는 하드 링크들도 실제 파일 시스템의 객체라 "real"로 소개한 것 같습니다.

```ts
node_modules
└── .pnpm
    ├── bar@1.0.0
    │   └── node_modules
    │       └── bar -> <store>
    └── foo@1.0.0
        └── node_modules
            ├── foo -> <store>
            └── bar -> ../../bar@1.0.0/node_modules/bar
```
`foo@1.0.0/node_modules` 폴더에서 `bar`로 심볼릭 링크를 만들어 참조합니다. 이걸로 `.pnpm/foo@1.0.0/...` 내부에서는 `bar`를 쓸 수 있게 됩니다.

```ts
node_modules
├── foo -> ./.pnpm/foo@1.0.0/node_modules/foo
└── .pnpm
    ├── bar@1.0.0
    │   └── node_modules
    │       └── bar -> <store>
    └── foo@1.0.0
        └── node_modules
            ├── foo -> <store>
            └── bar -> ../../bar@1.0.0/node_modules/bar
```
이 프로젝트는 `foo`만 의존성이 있습니다. 루트인 `node_modules` 폴더에서 `foo`에 대해 심볼릭 링크를 생성합니다.

```ts
node_modules
├── foo -> ./.pnpm/foo@1.0.0/node_modules/foo
└── .pnpm
    ├── bar@1.0.0
    │   └── node_modules
    │       ├── bar -> <store>
    │       └── qar -> ../../qar@2.0.0/node_modules/qar
    ├── foo@1.0.0
    │   └── node_modules
    │       ├── foo -> <store>
    │       ├── bar -> ../../bar@1.0.0/node_modules/bar
    │       └── qar -> ../../qar@2.0.0/node_modules/qar
    └── qar@2.0.0
        └── node_modules
            └── qar -> <store>
```
`foo`와 `bar` 모두에게 의존성이 있는 `qar@2.0.0`이 추가되는 상황에서 `.pnpm`의 폴더 구조는 위와 같이 됩니다. 보통 `node_modules/foo/node_modules/bar/node_modules/qar`의 구조로 폴더가 점점 깊어지고 의존성이 얽혀 복잡해질 것 같지만(예전 npm이 이랬다고 합니다) pnpm과 함께라면 위와 같은 방식으로 공유 구조가 만들어집니다.<br>

Node는 `require`나 `import`로 모듈을 찾을 때 심볼릭 링크를 그냥 실제 파일인 것처럼 취급합니다. 예를 들어, `foo@1.0.0/node_modules/foo/index.js` 안에서 `require('bar')`를 하면 Node는 현재 위치 기준으로 `node_modules/bar`를 찾으려다가 심볼릭 링크를 따라가서 `.pnpm/bar@1.0.0/node_modules/bar`의 실제 위치를 찾아냅니다. 이렇게 pnpm은 Node의 모듈 해석 방식과 호환되면서 효율적인 트리를 만들 수 있습니다.

### Hoisting
위의 시나리오를 npm에서 설치하면 아래와 같은 구조가 만들어집니다.
```ts
node_modules
├── foo@1.0.0
├── bar@1.0.0
├── qar@2.0.0
└── ...
```
프로젝트에서 필요한 `foo@1.0.0`를 포함한 모든 패키지들이 루트인 `node_modules`로 올라와 누가 누구에게 의존적인지 모르게 됩니다.
여기서 유령 의존성 문제가 발생할 수 있는데, 예를 들어 `package.json`에 `bar`를 명시하지 않았는데도 접근이 가능한 문제가 생깁니다.<br>
하지만 pnpm은 폴더 내부에서 의존성을 심볼릭 링크로 구성함으로서 이를 구조적으로 차단할 수 있습니다!

### 유령 의존성
- `foo`가 `bar`를 `require`하는 건 정상적인 의존성입니다
  - `bar`는 `foo`의 `dependencies`에 명시돼있기 때문에 pnpm은 `foo`의 심볼릭 링크를 통해 접근 가능하게 해줍니다
- 직접적으로 의존하지 않는데 접근 가능한 상황이 유령 의존성입니다
  - 프로젝트에서 `foo`만 설치했는데 `import bar from 'bar';`가 성공하는 상황을 말합니다
  - npm 환경에서 `foo`가 의존하는 `bar`가 루트에 끌려올라와있어서 코드가 작동할 수 있습니다
- pnpm은 이런 상황을 막아줍니다
  - `bar`를 `node_modules`에 올려두지 않고, 오직 `foo`의 내부에만 두기 때문입니다
  - `bar`를 쓰고 싶으면 `pnpm add bar`로 직접 의존성에 추가해야 합니다

## 패키지 매니저별 설치 시간 비교
<img src='/images/alotta-files.svg' width="800">

*Last benchmarked at: Oct 26, 2025, 3:07 AM (daily updated)*

### 주표 지표
- `clean install`:
  - 완전히 새로 설치하는 데에 걸리는 시간
  - npm은 전역 캐시에 저장한 후, 프로젝트의 `node_modules`에 직접 복사합니다 -> 파일 복사 I/O가 발생합니다
  - pnpm은 전역 스토어에 저장한 후, 프로젝트에서 전역 스토어로 하드 링크를 생성합니다
  - 최초 설치라 시간에 차이가 없어야 한다고 생각했는데 pnpm이 훨씬 빠릅니다
- `with node_modules`:
  - 이미 `node_modules`가 있고, `package-lock.json`과 내용이 일치하는 상황에서 install을 또 수행하는 경우
  - npm: 트리를 빠르게 비교해 변경이 없으면 빨리 종료합니다
  - pnpm: 하드/심볼릭 링크 레이아웃 검증에 리소스가 소요됩니다

또 패키지 매니저의 동작 단계에서 pnpm은 설치를 병렬적으로 수행하는 것 같습니다.

<img src='/images/pnpm.svg' width="600">

이 방식은 전통적인 정보 수집, 다운로드, `node_modules`에 종속성을 연결하는 기존의 순차적인 프로세스보다 훨씬 빠릅니다.

<img src='/images/traditional.svg' width="600">

## 결론
설치 속도나 디스크 효율 측면에서 pnpm이 훨씬 유리해 보이는데, 사용하지 않을 이유가 있을까요?
<br><br>

*출처:<br>
[1] pnpm 공식 문서 (["Symlinked node_modules structure"](https://pnpm.io/symlinked-node-modules-structure), ["Benchmarks of JavaScript Package Managers"](https://pnpm.io/benchmarks)
["Motivation"](https://pnpm.io/motivation))<br>
[2] 이것이 취업을 위한 컴퓨터 과학이다, 강민철 저, 한빛미디어, 2024, p.235-236<br>
[3] 코드잇 FESI 11기 강의자료*
