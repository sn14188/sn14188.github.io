---
title: "Hydration"
date: 2026-02-04
---

이번 포스트에서는 hydration의 개념과, SSG/SSR 환경에서 hydration의 역할, hydration 이슈와 대응 방안에 대해 살펴봤습니다.
<br><br>

## Hydration

웹 개발에서 hydration은 정적 렌더링이나 서버 사이드 렌더링을 통해 전달된 HTML에 클라이언트 측 자바스크립트가 이벤트 핸들러를 연결해 정적인 페이지를 동적인 웹 애플리케이션으로 전환하는 과정을 의미합니다.<br>
HTML이 서버에서 미리 렌더링돼 전달되기 때문에, 사용자에게 의미 있는 콘텐츠가 처음 화면에 표시되는 시점인 FCP는 빠르게 이루어집니다.<br>
하지만 이 시점에서는 아직 자바스크립트가 실행되지 않았기 때문에 페이지와 상호작용이 가능한 상태는 아닙니다.
이후 클라이언트 측 자바스크립트가 실행되고 이벤트 핸들러가 연결되면서 비로소 페이지는 사용자 입력에 반응할 수 있는 상태가 됩니다.

### 렌더링 종류

웹 애플리케이션에서 HTML을 생성한다는 것은, 데이터를 기반으로 브라우저가 해석할 수 있는 마크업 구조를 만들어내는 과정을 뜻합니다.<br>
어디에서 이 작업이 수행되느냐에 따라 렌더링 방식을 구분할 수 있는데, 이는 성능과 사용자 경험에 직접적인 영향을 미칩니다.

- CSR:
  - 브라우저에서 자바스크립트를 실행해 화면을 그리는 방식입니다
  - 초기 로딩 시 자바스크립트 의존도가 높고, 첫 화면 표시가 느릴 수 있다는 특징이 있습니다
- SSG:
  - 빌드 시점에 미리 HTML을 생성해두고 요청 시 이미 만들어진 파일을 그대로 전달하는 방식입니다
  - 콘텐츠 변경이 잦은 경우에는 적합하지 않지만 응답 속도가 매우 빠릅니다
- SSR:
  - 요청이 들어올 때 서버에서 HTML을 생성해 클라이언트에 전달하는 방식입니다
  - SEO와 초기 렌더링 성능이 중요한 서비스에 적합합니다

SSG와 SSR은 공통적으로 HTML을 서버에서 먼저 생성한다는 특징이 있습니다.
이 HTML은 아직 상호작용이 불가능한 상태이기 때문에, 자바스크립트를 통해 이벤트와 상태를 연결하는 hydration 과정이 필요합니다.<br>
CSR에서는 렌더링이 브라우저에서 처음부터 자바스크립트로 일어나기 때문에 hydration이 필요하지 않습니다.<br>

## Hydration 과정

브라우저가 서버로부터 받은 HTML을 파싱해 DOM을 생성하고, hydration은 이후에 수행됩니다. 먼저 전체 흐름을 간단히 정리하면 다음과 같습니다.

1. 서버에서 렌더링된 HTML이 브라우저에 전달됩니다
2. 브라우저는 HTML을 파싱해 DOM을 생성하고 화면에 표시합니다
3. 클라이언트 측 자바스크립트가 로드됩니다
4. hydration이 수행되어 페이지가 상호작용 가능한 형태로 전환됩니다

이제 4번의 hydration 과정을 조금 더 자세히 살펴보겠습니다.

### 클라이언트에서 `hydrateRoot`가 호출됩니다

`hydrateRoot`:

- 기존 DOM과 리액트 애플리케이션을 연결하는 클라이언트 API입니다
- 서버에서 이미 렌더링된 HTML이 DOM으로 존재하는 상태를 전제로 합니다
- 이 API는 DOM을 재사용하기 위해 설계되었기 때문에 CSR 애플리케이션의 초기 마운트에는 사용되지 않습니다

`hydrateRoot`가 호출되면 리액트는 전달된 요소를 루트로 삼아 컴포넌트 함수를 다시 실행하고, 리액트 내부 구조인 컴포넌트 트리를 생성합니다.

- Fiber 트리라고도 합니다
- 리액트에서는 가상 DOM 개념을 이 구조를 통해 구현합니다

### DOM과 컴포넌트 결과를 매칭합니다

hydration 중 DOM과 클라이언트에서 또 생성된 컴포넌트 트리를 비교합니다.<br>
이 과정에서 리액트는 DOM 구조가 컴포넌트 트리와 일치하면, 기존 DOM을 그대로 재사용하고 해당 DOM 노드를 리액트 내부 구조에 연결합니다.
이 과정을 통해 리액트는 이 DOM 조각이 어떤 컴포넌트의 렌더링 결과인지를 인식할 수 있게 됩니다.<br>
만약 이 과정에서 DOM 구조가 다를 경우, 리액트는 hydration mismatch 경고를 출력합니다.

### 이벤트, 상태, `ref`가 연결됩니다

이 단계가 완료되면 페이지는 사용자 입력에 반응할 수 있는 완전한 상태가 됩니다.

- 이벤트 리스너 등록: 각 이벤트를 브라우저 API로 등록합니다
- 컴포넌트 상태: 클라이언트에서 상태를 처음으로 생성하고 관리하기 시작합니다
- `ref` 연결: 서버에는 DOM이 없기 때문에 hydration 과정에서 실제 DOM 노드와 연결됩니다

## 왜 알아야 할까요

실제로 Next.js와 같은 프레임워크를 사용하는 경우, 개발자가 `hydrateRoot`를 직접 호출할 일은 거의 없습니다.<br>
하지만 클라이언트에서 리액트 애플리케이션이 상호작용 가능한 상태로 전환되는 시점에는, 프레임워크 내부에서 `hydrateRoot`가 호출되어 완전한 상태가 된다는 것은 알아야 합니다.

## Hydration 이슈와 대응 방안

hydration 이슈는 서버에서 렌더링해 전달한 HTML과, 클라이언트에서 hydration 과정 중 리액트가 다시 계산한 초기 렌더 결과가 서로 일치하지 않을 때 발생합니다.

1. HTML 태그 중첩이 잘못된 경우
   - 브라우저는 HTML을 파싱할 때 잘못된 중첩을 만나는 경우 DOM을 수정할 수 있기 때문에, 서버가 만든 HTML과 브라우저가 만든 DOM 구조가 달라져 mismatch가 발생할 수 있습니다
     - `<p>` 태그 안에 또 `<p>` 태그
     - `<p>` 태그 안에 `<div>` 태그
     - `<p>` 태그 안에 `<ul>`나 `<ol>` 태그
     - `<a>` 태그 안에 `<a>` 태그, `<button>` 태그 안에 `<button>` 태그 등
   - 대응 방안: HTML 명세에 맞도록 태그를 사용하고, 구조가 복잡해지면 브라우저가 허용하지 않는 중첩이 있는지 확인해야 합니다

2. 렌더링 로직에서 `typeof window !== 'undefined'` 사용
   - 서버 렌더링 시점에는 `window`가 없고 클라이언트에는 있어서 초기 렌더 결과가 달라질 수 있습니다
   - 대응 방안: 클라이언트 전용 UI를 hydration 이후에 렌더링되도록 분리함으로써 해결할 수 있습니다

3. 렌더링 로직에서 `window`, `localStorage` 같은 브라우저 전용 API를 사용하는 경우
   - 브라우저에만 존재하는 API의 값을 이용해 초기 UI를 바로 결정하면 렌더 결과가 달라질 수 있습니다
   - 대응 방안: 브라우저 전용 API 접근은 `useEffect` 이후로 미루고, 서버와 클라이언트 모두에서 동일한 기본 UI를 먼저 렌더링한 뒤 클라이언트에서 상태를 보정하는 방식으로 구현합니다

4. 렌더링 로직에서 `Date()` 같은 시간 의존적인 값을 사용하는 경우
   - 시간이나 랜덤값은 실행 시점에 따라 결과가 달라집니다
   - 대응 방안: `Date()`, `Date.now()`, `Math.random()` 같은 값들은 초기 렌더 결과에서 제외하고, 필요한 경우 hydration 이후에 상태로 설정합니다

5. 브라우저 확장 프로그램이 HTML을 수정하는 경우
   - 번역이나 광고 차단 같은 일부 브라우저 확장 프로그램이 hydration 이전에 DOM에 속성을 삽입할 수 있습니다
   - 대응 방안: 확장 프로그램을 비활성화한 환경에서도 재현되는지 확인하는 등 환경 요인을 점검해야 합니다

6. CSS-in-JS 라이브러리 설정이 잘못된 경우
   - CSS-in-JS는 서버와 클라이언트에서 `className`을 생성하는 순서가 어긋나면 속성이 달라져 mismatch를 유발할 수 있습니다
   - 대응 방안: 프레임워크 공식 문서에서 제공하는 SSR 설정을 잘 따름으로써 방지할 수 있습니다

7. Edge/CDN가 HTML 응답을 변경하는 경우
   - Edge나 CDN은 중간 인프라로, 사용자와 서버 사이에 위치하며 요청과 응답을 전달하는 과정에서 HTML 응답을 가공할 수 있습니다
   - 이 과정에서 공백 제거, 속성 정렬 등의 변화가 발생하면 구조가 달라질 수 있습니다
   - 대응 방안: 자동으로 변형되는 옵션을 점검하고, HTML을 그대로 전달하도록 설정해야 합니다

## Takeaways

1. SSG와 SSR에서는 서버에서 HTML을 생성해 전달합니다
2. hydration은 생성된 DOM을 재사용하면서 리액트 컴포넌트 트리를 구성하고 이벤트와 상태를 연결해 페이지를 상호작용 가능하게 만드는 과정입니다
3. hydration 이슈는 브라우저에 존재하는 DOM과 hydration 시점에 컴포넌트 트리와 일치하지 않을 때 발생합니다
   <br><br>
