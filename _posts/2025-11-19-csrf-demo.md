---
title: "CSRF Demo"
date: 2025-11-19
---

부트캠프 중 접했었던 CSRF 공격 예제를 직접 구현해본 기록입니다.
<br><br>

## 데모 구성

`Express`로 서버를 만들고, 사용자가 로그인하면 정해진 쿠키가 발급되도록 설정했습니다.<br>
`victim` 페이지에서 로그인할 수 있고, 특정 버튼을 클릭하면 `attacker` 페이지로 이동합니다.<br>
`attacker` 페이지에서는 `useEffect`로 `fetch` 요청을 자동으로 보내도록 구성해, `victim`에서 받은 쿠키가 그대로 함께 전송되면서 CSRF 요청이 만들어지는 흐름이었습니다.

### 초기 쿠키 설정

쿠키의 옵션들을 공부하면서 처음 사용한 설정은 다음과 같았습니다.

```ts
res.cookie("token", "token-value", {
  httpOnly: true,
  sameSite: "none",
  secure: false,
  maxAge: 1000 * 60 * 60 * 24,
});
```

- `secure: true`는 HTTPS에서만 쿠키를 전송하는 조건이라 하여 로컬에서는 동작하지 않을 것 같아 `secure: false`로 설정했습니다
- cross-site 요청에서도 쿠키를 전송하기 위해 `sameSite: "none"`도 함께 사용했습니다

<img src='/images/csrf/login-success.png' width="800">
<img src='/images/csrf/login-cookie.png' width="800">

그런데 로그인 직후 브라우저에는 쿠키가 정상적으로 생성됐는데, `attacker`에서 보낸 요청에는 쿠키가 `undefined`로 나오는 문제가 있었고, 개발자 도구에도 나타나지 않았습니다.<br>

```bash
(base) aidenseo@Aidens-MacBook-Pro server % pnpm start

> server@1.0.0 start /Users/aidenseo/Desktop/csrf-demo/server
> node app.js

server running on port 4000
csrf triggered: { cookie: undefined, referer: 'http://localhost:3001/' }
```

<img src='/images/csrf/attack-fail.png' width="800">

## 문제 원인 분석

관련 검색을 통해 다음 사실들을 확인했습니다.

1. `SameSite=None`를 사용하는 쿠키는 반드시 `Secure`여야 한다는 것
   - `sameSite: "none"`과 `secure: false`의 조합은 표준에 맞지 않아 브라우저가 거부하는 동작이었을 것입니다
2. 디폴트는 `SameSite=Lax`
   - `SameSite`를 명시적으로 지정하지 않은 쿠키는 `SameSite=Lax`로 처리됩니다
   - 이 조건에서는 페이지 이동을 일으키는 `GET` 요청에 한해 쿠키가 전송됩니다

## SameSite 옵션 제거 후 재시도

이 사실들을 알고 난 뒤, 아예 `sameSite` 옵션을 제거한 뒤 다시 테스트했습니다.
이번에는 `attacker` 페이지에서 쿠키가 정상적으로 전송되는 것을 확인할 수 있었습니다.<br>

```bash
(base) aidenseo@Aidens-MacBook-Pro server % pnpm start

> server@1.0.0 start /Users/aidenseo/Desktop/csrf-demo/server
> node app.js

server running on port 4000
csrf triggered: { cookie: 'token-value', referer: 'http://localhost:3001/' }
```

<img src='/images/csrf/attack-success.png' width="800">

## 로컬 환경에서 Secure 쿠키 테스트

추가로, `sameSite: "none"`와 `secure: true` 조합을 로컬에서 재현할 수 있는지가 궁금해졌습니다.<br>
원칙적으로 `secure: true`는 `HTTPS` 환경에서만 쿠키를 전송해야 하는데, 놀랍게도 `localhost`에서는 쿠키가 정상적으로 전송되었습니다.<br>
이유를 알아보니 브라우저는 `localhost`를 "잠재적으로 신뢰할 수 있는 출처"로 간주하기 때문이라고 했습니다.

### 잠재적으로 신뢰할 수 있는 출처

잠재적으로 신뢰할 수 있는 출처란, 엄밀히 보안 기준을 충족하지 못하지만 브라우저가 일반적으로 데이터 보안을 제공할 수 있다고 믿을 수 있는 오리진입니다.<br>로컬에서 전송되는 리소스 및 `URL`은 `HTTPS`를 통해 전송되지 않지만, 브라우저와 동일한 기기에 있기 때문에 안전하게 전송되는 걸로 간주할 수 있다고 합니다.

## Takeaways

1. 쿠키의 `Samesite=None`과 `Secure=false` 조합은 브라우저가 거부하는 동작일 수 있습니다
2. `SameSite`를 지정하지 않으면 `SameSite=Lax`가 디폴트입니다
3. `Secure` 쿠키는 원칙적으로 `HTTPS`에서만 전송되지만, 브라우저는 `localhost`를 잠재적으로 신뢰할 수 있는 출처로 판단해 쿠키가 전송될 수 있습니다
   <br><br>

_출처:<br>
[1] 코드잇 FESI 11기 강의자료<br>
[2] web.dev (["SameSite cookies explained"](https://web.dev/articles/samesite-cookies-explained))<br>
[3] The Chromium Projects (["Cookie Legacy SameSite Policies"](https://www.chromium.org/administrators/policy-list-3/cookie-legacy-samesite-policies/))<br>
[4] MDN Docs (["Secure contexts"](https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts))<br>_
